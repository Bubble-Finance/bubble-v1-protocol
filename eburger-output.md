# eBurger Static Analysis Report

This report was generated by the [eburger](https://github.com/forefy/eburger) static analyzer on 10.04.2025 at 11:43.

The results are not intended to substitute for comprehensive audits or professional assessments, and should be used only as a tool to help identify possible security vulnerabilities or insights and not for any other purpose.

## Insights Summary

| Issue | Severity | Occurrences |
|-------|----------|-------------|
| [[Low] Unverified from Address Usage in transferFrom](#low-unverified-from-address-usage-in-transferfrom) | Low | 1 |
| [[Medium] Use of transfer or send on a payable address](#medium-use-of-transfer-or-send-on-a-payable-address) | Medium | 2 |
| [[Low] Unbounded Loop](#low-unbounded-loop) | Low | 2 |
| [[Medium] Usage of unsafe _mint](#medium-usage-of-unsafe-_mint) | Medium | 8 |
| [[Low] Missing Reentracy Guard](#low-missing-reentracy-guard) | Low | 7 |
| [[Low] Missing Zero Address Check](#low-missing-zero-address-check) | Low | 27 |
| [[Low] Unspecific Solidity Pragma Detector](#low-unspecific-solidity-pragma-detector) | Low | 51 |


### [Low] Unverified from Address Usage in transferFrom
Employing an unverified from address in transferFrom or safeTransferFrom operations poses a substantial risk of fund loss. This risk arises from the potential for any party to execute token transfers from the specified from address, contingent upon having received adequate approval.

#### Vulnerable Locations
- src/raffle/BubbleV1Raffle.sol:374:9-49
	```
	super.transferFrom(_from, _to, _tokenId)
	```

#### Action Items
- Verify that the from address used in calls to transferFrom or safeTransferFrom is validated properly.

#### References
- [https://solidity.readthedocs.io/en/latest/types.html#members-of-addresses](https://solidity.readthedocs.io/en/latest/types.html#members-of-addresses)

---

### [Medium] Use of transfer or send on a payable address
In Solidity, .transfer and .send both implement a risky gas limitation that reverts the transaction if the recipient's operations require more gas than the stipend of 2300 gas.

#### Vulnerable Locations
- test/utils/WNative.sol:32:9-42
	```
	payable(msg.sender).transfer(wad)
	```
- test/utils/WrappedMonad.sol:35:9-42
	```
	payable(msg.sender).transfer(wad)
	```

#### Action Items
- Replace .transfer or .send with .call for transfers to payable addresses.
- Implement necessary checks and error handling to ensure the safety of the new .call usage.

#### References
- [https://docs.soliditylang.org/en/v0.8.0/080-breaking-changes.html#new-recommendations](https://docs.soliditylang.org/en/v0.8.0/080-breaking-changes.html#new-recommendations)

---

### [Low] Unbounded Loop
Unbounded loops, specifically, for loops that can modify state and have no apparent max restriction to the nunmber of iterations possible, can lead to excessive gas consumption, which may cause transactions to fail or become prohibitively expensive.

#### Vulnerable Locations
- test/baseHelpers/InitializeActors.sol:124:9-54
	```
	for (uint256 i = 0; i < actors.length; ++i) {
	            wETH.mint(actors[i], TOKEN_1M);
	            wBTC.mint(actors[i], TOKEN_1M);
	            USDT.mint(actors[i], TOKEN_1M);
	            DAI.mint(actors[i], TOKEN_1M);
	            SHIB.mint(actors[i], TOKEN_1M);
	        }
	```
- test/baseHelpers/InitializeActors.sol:133:9-54
	```
	for (uint256 i = 0; i < actors.length; ++i) {
	            vm.deal(actors[i], TOKEN_1M);
	        }
	```

#### Action Items
- Review raised loops and ensure there are acceptable limitations of maximum iterations.
- If possible, reduce the complication of loops and see if there's any other way to provide a similar functionality with a smaller range of iterations required, if at all.

#### References
- [https://blog.b9lab.com/getting-loopy-with-solidity-1d51794622ad](https://blog.b9lab.com/getting-loopy-with-solidity-1d51794622ad)

---

### [Medium] Usage of unsafe _mint
ERC721 _mint is used for token creation and updates the internal mappings of token ownership. Instead of using _mint directly, it's preferrable to use _safeMint, which is a safer extension of the _mint function, that's adding a security check meant to verify that if the recipient address is a contract - it's a contract that can handle ERC721 tokens correctly (by calling that contract's onERC721Received function).

#### Vulnerable Locations
- src/campaigns/ERC20Launchable.sol:51:9-40
	```
	_mint(msg.sender, _totalSupply)
	```
- src/core/BubbleV1Pool.sol:172:13-61
	```
	_mint(initialLPTokenReceiver, MINIMUM_LIQUIDITY)
	```
- src/core/BubbleV1Pool.sol:179:9-41
	```
	_mint(_receiver, lpTokensToMint)
	```
- src/core/BubbleV1Pool.sol:403:41-84
	```
	_mint(protocolTeamMultisig, lpTokensToMint)
	```
- src/governance/BubbleGovernanceToken.sol:30:9-38
	```
	_mint(_owner, _initialSupply)
	```
- test/utils/DangerousToken.sol:39:9-26
	```
	_mint(to, amount)
	```
- test/utils/FeeOnTransferTokenMock.sol:27:9-60
	```
	_mint(msg.sender, initialSupply * 10 ** decimals())
	```
- test/utils/TokenMock.sol:39:9-26
	```
	_mint(to, amount)
	```

#### Action Items
- Review calls to _mint in your contract, and if there's ever a chance of the recipient address of being a contact, replace it with a _safeMint implementation.
- If there isn't a possibility that the recipient will ever be a contract, you may keep using _mint to save gas costs.

#### References
- [https://github.com/OpenZeppelin/openzeppelin-contracts/blob/d4d8d2ed9798cc3383912a23b5e8d5cb602f7d4b/contracts/token/ERC721/ERC721.sol#L271](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/d4d8d2ed9798cc3383912a23b5e8d5cb602f7d4b/contracts/token/ERC721/ERC721.sol#L271)
- [https://www.appsloveworld.com/ethereum/57/openzeppelin-erc721-difference-between-safemint-and-mint](https://www.appsloveworld.com/ethereum/57/openzeppelin-erc721-difference-between-safemint-and-mint)

---

### [Low] Missing Reentracy Guard
Due to Solidity's design, when a function in your contract interacts with another contract's address, that contract gains the ability to recursively call your contract's function before handing back the control on the execution flow. If the reentrant function's logic did not expect the function to be called multiple times, it can be exposed to abuse.

#### Vulnerable Locations
- src/router/BubbleV1Router.sol:116:5-33
	```
	function addLiquidityNative(
	        BubbleV1Types.AddLiquidityNative calldata _addLiquidityNativeParams
	    )
	        external
	        payable
	        beforeDeadline(_addLiquidityNativeParams.deadline)
	        returns (uint256, uint256, uint256)
	    {
	        (uint256 amountToken, uint256 amountNative) = _addLiquidityHelper(
	            _addLiquidityNativeParams.token,
	            i_wNative,
	            _addLiquidityNativeParams.amountTokenDesired,
	            msg.value,
	            _addLiquidityNativeParams.amountTokenMin,
	            _addLiquidityNativeParams.amountNativeTokenMin
	        );
	        address pool =
	            BubbleV1Library.getPool(i_factory, _addLiquidityNativeParams.token, i_wNative);
	        IERC20(_addLiquidityNativeParams.token).safeTransferFrom(msg.sender, pool, amountToken);
	        IWNative(payable(i_wNative)).deposit{ value: amountNative }();
	        IERC20(i_wNative).safeTransfer(pool, amountNative);
	        uint256 lpTokensMinted =
	            IBubbleV1Pool(pool).addLiquidity(_addLiquidityNativeParams.receiver);
	        if (msg.value > amountNative) {
	            (bool success,) = payable(msg.sender).call{ value: msg.value - amountNative }("");
	            if (!success) revert BubbleV1Router__TransferFailed();
	        }
	
	        return (amountToken, amountNative, lpTokensMinted);
	    }
	```
- src/router/BubbleV1Router.sol:218:5-65
	```
	function removeLiquidityNativeSupportingFeeOnTransferTokens(
	        address _token,
	        uint256 _lpTokensToBurn,
	        uint256 _amountTokenMin,
	        uint256 _amountNativeMin,
	        address _receiver,
	        uint256 _deadline
	    )
	        public
	        beforeDeadline(_deadline)
	        returns (uint256)
	    {
	        (, uint256 amountNative) = removeLiquidity(
	            _token,
	            i_wNative,
	            _lpTokensToBurn,
	            _amountTokenMin,
	            _amountNativeMin,
	            address(this),
	            _deadline
	        );
	
	        IERC20(_token).safeTransfer(_receiver, IERC20(_token).balanceOf(address(this)));
	        IWNative(payable(i_wNative)).withdraw(amountNative);
	        (bool success,) = payable(msg.sender).call{ value: amountNative }("");
	        if (!success) revert BubbleV1Router__TransferFailed();
	
	        return amountNative;
	    }
	```
- src/router/BubbleV1Router.sol:437:5-39
	```
	function swapTokensForExactNative(
	        uint256 _amountOut,
	        uint256 _amountInMax,
	        address[] calldata _path,
	        address _receiver,
	        uint256 _deadline,
	        BubbleV1Types.Raffle memory _raffle
	    )
	        external
	        beforeDeadline(_deadline)
	        returns (uint256[] memory, uint256)
	    {
	        if (_path[_path.length - 1] != i_wNative) revert BubbleV1Router__InvalidPath();
	        uint256[] memory amounts = BubbleV1Library.getAmountsIn(i_factory, _amountOut, _path);
	        if (amounts[0] > _amountInMax) {
	            revert BubbleV1Router__ExcessiveInputAmount(amounts[0], _amountInMax);
	        }
	        IERC20(_path[0]).safeTransferFrom(
	            msg.sender, BubbleV1Library.getPool(i_factory, _path[0], _path[1]), amounts[0]
	        );
	        _swap(amounts, _path, address(this));
	        IWNative(payable(i_wNative)).withdraw(amounts[amounts.length - 1]);
	        (bool success,) = payable(_receiver).call{ value: amounts[amounts.length - 1] }("");
	        if (!success) revert BubbleV1Router__TransferFailed();
	
	        uint256 nftId;
	        if (_raffle.enter) {
	            nftId = _enterRaffle(
	                _path, amounts, _raffle.fractionOfSwapAmount, _raffle.raffleNftReceiver
	            );
	        }
	
	        return (amounts, nftId);
	    }
	```
- src/router/BubbleV1Router.sol:484:5-39
	```
	function swapExactTokensForNative(
	        uint256 _amountIn,
	        uint256 _amountOutMin,
	        address[] calldata _path,
	        address _receiver,
	        uint256 _deadline,
	        BubbleV1Types.Raffle memory _raffle
	    )
	        external
	        beforeDeadline(_deadline)
	        returns (uint256[] memory, uint256)
	    {
	        if (_path[_path.length - 1] != i_wNative) revert BubbleV1Router__InvalidPath();
	        uint256[] memory amounts = BubbleV1Library.getAmountsOut(i_factory, _amountIn, _path);
	        if (amounts[amounts.length - 1] < _amountOutMin) {
	            revert BubbleV1Router__InsufficientOutputAmount(
	                amounts[amounts.length - 1], _amountOutMin
	            );
	        }
	        IERC20(_path[0]).safeTransferFrom(
	            msg.sender, BubbleV1Library.getPool(i_factory, _path[0], _path[1]), amounts[0]
	        );
	        _swap(amounts, _path, address(this));
	        IWNative(payable(i_wNative)).withdraw(amounts[amounts.length - 1]);
	        (bool success,) = payable(_receiver).call{ value: amounts[amounts.length - 1] }("");
	        if (!success) revert BubbleV1Router__TransferFailed();
	
	        uint256 nftId;
	        if (_raffle.enter) {
	            nftId = _enterRaffle(
	                _path, amounts, _raffle.fractionOfSwapAmount, _raffle.raffleNftReceiver
	            );
	        }
	
	        return (amounts, nftId);
	    }
	```
- src/router/BubbleV1Router.sol:532:5-39
	```
	function swapNativeForExactTokens(
	        uint256 _amountOut,
	        address[] calldata _path,
	        address _receiver,
	        uint256 _deadline,
	        BubbleV1Types.Raffle memory _raffle
	    )
	        external
	        payable
	        beforeDeadline(_deadline)
	        returns (uint256[] memory, uint256)
	    {
	        if (_path[0] != i_wNative) revert BubbleV1Router__InvalidPath();
	        uint256[] memory amounts = BubbleV1Library.getAmountsIn(i_factory, _amountOut, _path);
	        if (amounts[0] > msg.value) {
	            revert BubbleV1Router__ExcessiveInputAmount(amounts[0], msg.value);
	        }
	        IWNative(payable(i_wNative)).deposit{ value: amounts[0] }();
	        IERC20(i_wNative).safeTransfer(
	            BubbleV1Library.getPool(i_factory, _path[0], _path[1]), amounts[0]
	        );
	        _swap(amounts, _path, _receiver);
	        if (msg.value > amounts[0]) {
	            (bool success,) = payable(msg.sender).call{ value: msg.value - amounts[0] }("");
	            if (!success) revert BubbleV1Router__TransferFailed();
	        }
	
	        uint256 nftId;
	        if (_raffle.enter) {
	            nftId = _enterRaffle(
	                _path, amounts, _raffle.fractionOfSwapAmount, _raffle.raffleNftReceiver
	            );
	        }
	
	        return (amounts, nftId);
	    }
	```
- src/router/BubbleV1Router.sol:673:5-68
	```
	function swapExactTokensForNativeSupportingFeeOnTransferTokens(
	        uint256 _amountIn,
	        uint256 _amountOutMin,
	        address[] calldata _path,
	        address _receiver,
	        uint256 _deadline,
	        BubbleV1Types.Raffle memory _raffle
	    )
	        external
	        beforeDeadline(_deadline)
	    {
	        if (_path[_path.length - 1] != i_wNative) revert BubbleV1Router__InvalidPath();
	
	        IERC20(_path[0]).safeTransferFrom(
	            msg.sender, BubbleV1Library.getPool(i_factory, _path[0], _path[1]), _amountIn
	        );
	
	        _swapSupportingFeeOnTransferTokens(_path, address(this));
	
	        uint256 amountOut = IERC20(i_wNative).balanceOf(address(this));
	        if (amountOut < _amountOutMin) {
	            revert BubbleV1Router__InsufficientOutputAmount(amountOut, _amountOutMin);
	        }
	
	        IWNative(payable(i_wNative)).withdraw(amountOut);
	        (bool success,) = payable(_receiver).call{ value: amountOut }("");
	        if (!success) revert BubbleV1Router__TransferFailed();
	
	        uint256 nftId;
	        if (_raffle.enter) {
	            uint256[] memory amounts = new uint256[](2);
	            amounts[0] = _amountIn;
	            amounts[1] = amountOut;
	
	            nftId = _enterRaffle(
	                _path, amounts, _raffle.fractionOfSwapAmount, _raffle.raffleNftReceiver
	            );
	        }
	    }
	```
- src/router/BubbleV1Router.sol:764:5-36
	```
	function removeLiquidityNative(
	        address _token,
	        uint256 _lpTokensToBurn,
	        uint256 _amountTokenMin,
	        uint256 _amountNativeMin,
	        address _receiver,
	        uint256 _deadline
	    )
	        public
	        beforeDeadline(_deadline)
	        returns (uint256, uint256)
	    {
	        (uint256 amountToken, uint256 amountNative) = removeLiquidity(
	            _token,
	            i_wNative,
	            _lpTokensToBurn,
	            _amountTokenMin,
	            _amountNativeMin,
	            address(this),
	            _deadline
	        );
	
	        IERC20(_token).safeTransfer(_receiver, amountToken);
	        IWNative(payable(i_wNative)).withdraw(amountNative);
	        (bool success,) = payable(_receiver).call{ value: amountNative }("");
	        if (!success) revert BubbleV1Router__TransferFailed();
	
	        return (amountToken, amountNative);
	    }
	```

#### Action Items
- Protect functions that may interact with other contracts by disallowing making nested (or re-entering) calls to them.
- Refer to ecosystem-trusted solutions, like OpenZeppelin's nonReentrant modifier.
- Review all raised functions for a correct implementation of the checks-effects-interactions pattern.

#### References
- [https://docs.openzeppelin.com/contracts/3.x/api/utils#ReentrancyGuard](https://docs.openzeppelin.com/contracts/3.x/api/utils#ReentrancyGuard)
- [https://swcregistry.io/docs/SWC-107/](https://swcregistry.io/docs/SWC-107/)

---

### [Low] Missing Zero Address Check
In Solidity, contracts often interact with external addresses. Failing to check for a possible 0 address input (especially in constructors, setters, and initializer functions) before such interactions can lead to unexpected dangerous behavior. A zero address check ensures that addresses are explicitly provided and not left uninitialized or set to a default, invalid state.

#### Vulnerable Locations
- node_modules/@pythnetwork/entropy-sdk-solidity/IEntropy.sol:111:9-25
	```
	address provider
	```
- node_modules/@pythnetwork/entropy-sdk-solidity/IEntropy.sol:121:28-43
	```
	address manager
	```
- src/campaigns/BubbleV1Campaigns.sol:136:9-33
	```
	address _monadexV1Router
	```
- src/campaigns/BubbleV1Campaigns.sol:137:9-25
	```
	address _wNative
	```
- src/campaigns/BubbleV1Campaigns.sol:138:9-23
	```
	address _vault
	```
- src/core/BubbleV1Factory.sol:101:9-38
	```
	address _protocolTeamMultisig
	```
- src/core/BubbleV1Factory.sol:168:9-38
	```
	address _protocolTeamMultisig
	```
- src/core/BubbleV1Pool.sol:136:25-40
	```
	address _tokenA
	```
- src/core/BubbleV1Pool.sol:136:42-57
	```
	address _tokenB
	```
- src/governance/BubbleGovernanceToken.sol:23:9-23
	```
	address _owner
	```
- src/interfaces/IBubbleV1Campaigns.sol:25:23-37
	```
	address _vault
	```
- src/interfaces/IBubbleV1Factory.sol:9:38-67
	```
	address _protocolTeamMultisig
	```
- src/interfaces/IBubbleV1Factory.sol:13:34-48
	```
	address _token
	```
- src/interfaces/IBubbleV1Factory.sol:15:30-45
	```
	address _tokenA
	```
- src/interfaces/IBubbleV1Factory.sol:15:47-62
	```
	address _tokenB
	```
- src/interfaces/IBubbleV1Pool.sol:7:25-40
	```
	address _tokenA
	```
- src/interfaces/IBubbleV1Pool.sol:7:42-57
	```
	address _tokenB
	```
- src/interfaces/IBubbleV1Raffle.sol:7:39-63
	```
	address _monadexV1Router
	```
- src/raffle/BubbleV1Raffle.sol:173:9-22
	```
	address _pyth
	```
- src/raffle/BubbleV1Raffle.sol:174:9-25
	```
	address _entropy
	```
- src/raffle/BubbleV1Raffle.sol:175:9-33
	```
	address _entropyProvider
	```
- src/router/BubbleV1Router.sol:69:17-33
	```
	address _factory
	```
- src/router/BubbleV1Router.sol:69:35-50
	```
	address _raffle
	```
- src/router/BubbleV1Router.sol:69:52-68
	```
	address _wNative
	```
- test/baseHelpers/MockEntropyContract.sol:14:17-33
	```
	address _entropy
	```
- test/baseHelpers/MockEntropyContract.sol:14:35-52
	```
	address _provider
	```
- test/utils/FeeOnTransferTokenMock.sol:19:9-29
	```
	address feeReceiver_
	```

#### Action Items
- Use require statements to validate addresses before any operation involving external addresses is performed, especially on constructors, setters or initializer functions.

#### References
- [https://detectors.auditbase.com/check-state-variable-address-zero-solidity](https://detectors.auditbase.com/check-state-variable-address-zero-solidity)

---

### [Low] Unspecific Solidity Pragma Detector
Detects the usage of unspecific compiler pragmas that allow for a broader range of compiler versions than necessary, which can lead to unintended behavior or compiler warnings/errors with newer versions.

#### Vulnerable Locations
- node_modules/@pythnetwork/entropy-sdk-solidity/EntropyEvents.sol:2:1-24
	```
	pragma solidity ^0.8.0;
	```
- node_modules/@pythnetwork/entropy-sdk-solidity/EntropyStructs.sol:3:1-24
	```
	pragma solidity ^0.8.0;
	```
- node_modules/@pythnetwork/entropy-sdk-solidity/IEntropy.sol:2:1-24
	```
	pragma solidity ^0.8.0;
	```
- node_modules/@pythnetwork/entropy-sdk-solidity/IEntropyConsumer.sol:2:1-24
	```
	pragma solidity ^0.8.0;
	```
- node_modules/@pythnetwork/pyth-sdk-solidity/AbstractPyth.sol:2:1-24
	```
	pragma solidity ^0.8.0;
	```
- node_modules/@pythnetwork/pyth-sdk-solidity/IPyth.sol:2:1-24
	```
	pragma solidity ^0.8.0;
	```
- node_modules/@pythnetwork/pyth-sdk-solidity/IPythEvents.sol:2:1-24
	```
	pragma solidity ^0.8.0;
	```
- node_modules/@pythnetwork/pyth-sdk-solidity/MockPyth.sol:2:1-24
	```
	pragma solidity ^0.8.0;
	```
- node_modules/@pythnetwork/pyth-sdk-solidity/PythErrors.sol:3:1-24
	```
	pragma solidity ^0.8.0;
	```
- node_modules/@pythnetwork/pyth-sdk-solidity/PythStructs.sol:2:1-24
	```
	pragma solidity ^0.8.0;
	```
- node_modules/@pythnetwork/pyth-sdk-solidity/PythUtils.sol:2:1-24
	```
	pragma solidity ^0.8.0;
	```
- script/utils/CampaignsScriptBase.sol:2:1-25
	```
	pragma solidity ^0.8.25;
	```
- script/utils/FactoryScriptBase.sol:2:1-25
	```
	pragma solidity ^0.8.25;
	```
- script/utils/GovernanceScriptBase.sol:2:1-25
	```
	pragma solidity ^0.8.25;
	```
- script/utils/RaffleScriptBase.sol:2:1-25
	```
	pragma solidity ^0.8.25;
	```
- script/utils/RouterScriptBase.sol:2:1-25
	```
	pragma solidity ^0.8.25;
	```
- script/utils/Utils.sol:2:1-25
	```
	pragma solidity ^0.8.25;
	```
- src/campaigns/BubbleV1Campaigns.sol:2:1-25
	```
	pragma solidity ^0.8.25;
	```
- src/campaigns/ERC20Launchable.sol:2:1-25
	```
	pragma solidity ^0.8.25;
	```
- src/core/BubbleV1Factory.sol:2:1-25
	```
	pragma solidity ^0.8.25;
	```
- src/core/BubbleV1Pool.sol:2:1-25
	```
	pragma solidity ^0.8.25;
	```
- src/governance/BubbleGovernanceToken.sol:2:1-25
	```
	pragma solidity ^0.8.25;
	```
- src/governance/BubbleV1Governor.sol:2:1-25
	```
	pragma solidity ^0.8.25;
	```
- src/governance/BubbleV1Timelock.sol:2:1-25
	```
	pragma solidity ^0.8.25;
	```
- src/interfaces/IBubbleV1Callee.sol:2:1-25
	```
	pragma solidity ^0.8.25;
	```
- src/interfaces/IBubbleV1Campaigns.sol:2:1-25
	```
	pragma solidity ^0.8.25;
	```
- src/interfaces/IBubbleV1Factory.sol:2:1-25
	```
	pragma solidity ^0.8.25;
	```
- src/interfaces/IBubbleV1Pool.sol:2:1-25
	```
	pragma solidity ^0.8.25;
	```
- src/interfaces/IBubbleV1Raffle.sol:2:1-25
	```
	pragma solidity ^0.8.25;
	```
- src/interfaces/IBubbleV1Router.sol:2:1-25
	```
	pragma solidity ^0.8.25;
	```
- src/interfaces/ILaunch.sol:2:1-25
	```
	pragma solidity ^0.8.25;
	```
- src/interfaces/IOwned.sol:2:1-25
	```
	pragma solidity ^0.8.25;
	```
- src/interfaces/IWNative.sol:2:1-25
	```
	pragma solidity ^0.8.25;
	```
- src/library/BubbleV1Library.sol:2:1-25
	```
	pragma solidity ^0.8.25;
	```
- src/library/BubbleV1Types.sol:2:1-25
	```
	pragma solidity ^0.8.25;
	```
- src/raffle/BubbleV1Raffle.sol:2:1-25
	```
	pragma solidity ^0.8.25;
	```
- src/router/BubbleV1Router.sol:2:1-25
	```
	pragma solidity ^0.8.25;
	```
- test/baseHelpers/Deployer.sol:2:1-25
	```
	pragma solidity ^0.8.24;
	```
- test/baseHelpers/Deployer2.sol:2:1-25
	```
	pragma solidity ^0.8.24;
	```
- test/baseHelpers/InitializeActors.sol:2:1-25
	```
	pragma solidity ^0.8.24;
	```
- test/baseHelpers/InitializeConstructorArgs.sol:2:1-25
	```
	pragma solidity ^0.8.24;
	```
- test/baseHelpers/InitializePythV2.sol:2:1-25
	```
	pragma solidity ^0.8.24;
	```
- test/baseHelpers/InitializeTokens.sol:2:1-25
	```
	pragma solidity ^0.8.24;
	```
- test/baseHelpers/MockEntropy.sol:2:1-25
	```
	pragma solidity ^0.8.24;
	```
- test/baseHelpers/MockEntropyContract.sol:2:1-25
	```
	pragma solidity ^0.8.24;
	```
- test/utils/DangerousToken.sol:2:1-25
	```
	pragma solidity ^0.8.24;
	```
- test/utils/FeeOnTransferTokenMock.sol:2:1-25
	```
	pragma solidity ^0.8.24;
	```
- test/utils/TokenMock.sol:2:1-25
	```
	pragma solidity ^0.8.24;
	```
- test/utils/WNative.sol:2:1-25
	```
	pragma solidity ^0.8.24;
	```
- test/utils/WrappedMonad.sol:2:1-25
	```
	pragma solidity ^0.8.24;
	```
- test/utils/vault.sol:2:1-25
	```
	pragma solidity ^0.8.24;
	```

#### Action Items
- Specify a more precise range of compiler versions in the pragma statement to ensure consistent behavior across different environments.

#### References
- [https://docs.soliditylang.org/en/latest/layout-of-source-files.html#version-pragma](https://docs.soliditylang.org/en/latest/layout-of-source-files.html#version-pragma)

---
<p align=center>Generated by <a href=https://github.com/forefy/eburger title="eBurger">eBurger</a> </p>
